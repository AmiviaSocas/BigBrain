import numpy as np
import matplotlib.pyplot as plt

# Paramètres du modèle de Hodgkin-Huxley simplifié
C_m = 1.0  # Capacité de la membrane (μF/cm^2)
g_Na = 120.0  # Conductance du canal sodium (mS/cm^2)
g_K = 36.0  # Conductance du canal potassium (mS/cm^2)
g_L = 0.3  # Conductance du courant de fuite (leakage) (mS/cm^2)
E_Na = 50.0  # Potentiel d'équilibre du sodium (mV)
E_K = -77.0  # Potentiel d'équilibre du potassium (mV)
E_L = -54.387  # Potentiel d'équilibre du courant de fuite (mV)

# Fonction de courant d'injection (stimulus externe)
def I_inj(t, I0=10.0, start=10.0, end=40.0):
    """
    Courant d'injection appliqué au neurone, simulateur d'un stimulus externe.
   
    Parameters:
    t (float): Temps en millisecondes
    I0 (float): Amplitude du courant (μA/cm^2)
    start (float): Début de l'injection de courant (ms)
    end (float): Fin de l'injection de courant (ms)
   
    Returns:
    courant_inj (float): Valeur du courant d'injection à l'instant t
    """
    if start <= t <= end:
        return I0
    else:
        return 0.0

# Fonctions de "gating" (ouverture et fermeture des canaux) pour sodium et potassium
def alpha_n(V):
    return 0.01 * (V + 55) / (1 - np.exp(-(V + 55) / 10))

def beta_n(V):
    return 0.125 * np.exp(-(V + 65) / 80)

def alpha_m(V):
    return 0.1 * (V + 40) / (1 - np.exp(-(V + 40) / 10))

def beta_m(V):
    return 4.0 * np.exp(-(V + 65) / 18)

def alpha_h(V):
    return 0.07 * np.exp(-(V + 65) / 20)

def beta_h(V):
    return 1.0 / (1 + np.exp(-(V + 35) / 10))

# Simuler le potentiel de membrane avec le modèle de Hodgkin-Huxley
def hodgkin_huxley(T, dt, I_inj_func):
    """
    Simule la dynamique du potentiel de membrane d'un neurone avec le modèle de Hodgkin-Huxley.

    Parameters:
    T (float): Temps total de la simulation (en ms)
    dt (float): Pas de temps (en ms)
    I_inj_func (function): Fonction du courant d'injection (stimulus externe)

    Returns:
    V_m (numpy array): Évolution du potentiel de membrane au cours du temps
    t_vals (numpy array): Temps associé à chaque valeur du potentiel
    """
    num_steps = int(T / dt)
   
    # Initialiser les variables
    V_m = np.zeros(num_steps)  # Potentiel de membrane (mV)
    V_m[0] = -65.0  # Potentiel de repos initial (mV)
    n = np.zeros(num_steps)  # Fraction des canaux K ouverts
    m = np.zeros(num_steps)  # Fraction des canaux Na ouverts
    h = np.zeros(num_steps)  # Fraction des canaux Na inactivés
   
    # Conditions initiales
    n[0] = alpha_n(V_m[0]) / (alpha_n(V_m[0]) + beta_n(V_m[0]))
    m[0] = alpha_m(V_m[0]) / (alpha_m(V_m[0]) + beta_m(V_m[0]))
    h[0] = alpha_h(V_m[0]) / (alpha_h(V_m[0]) + beta_h(V_m[0]))
   
    t_vals = np.linspace(0, T, num_steps)  # Temps en ms

    for i in range(1, num_steps):
        t = t_vals[i]
        I = I_inj_func(t)  # Courant d'injection à l'instant t
       
        # Équations de Hodgkin-Huxley
        g_Na_t = g_Na * m[i - 1]**3 * h[i - 1]
        g_K_t = g_K * n[i - 1]**4
        g_L_t = g_L

        I_Na = g_Na_t * (V_m[i - 1] - E_Na)  # Courant sodium
        I_K = g_K_t * (V_m[i - 1] - E_K)  # Courant potassium
        I_L = g_L_t * (V_m[i - 1] - E_L)  # Courant de fuite
       
        # Mise à jour du potentiel de membrane (mV)
        V_m[i] = V_m[i - 1] + (dt / C_m) * (I - I_Na - I_K - I_L)

        # Mise à jour des fractions de canaux ouverts/fermés
        n[i] = n[i - 1] + dt * (alpha_n(V_m[i - 1]) * (1 - n[i - 1]) - beta_n(V_m[i - 1]) * n[i - 1])
        m[i] = m[i - 1] + dt * (alpha_m(V_m[i - 1]) * (1 - m[i - 1]) - beta_m(V_m[i - 1]) * m[i - 1])
        h[i] = h[i - 1] + dt * (alpha_h(V_m[i - 1]) * (1 - h[i - 1]) - beta_h(V_m[i - 1]) * h[i - 1])

    return t_vals, V_m

# Simulation du modèle de Hodgkin-Huxley
T = 50.0  # Temps total en ms
dt = 0.01  # Pas de temps en ms
t_vals, V_m = hodgkin_huxley(T, dt, I_inj)

# Affichage du potentiel de membrane au fil du temps
plt.plot(t_vals, V_m)
plt.title('Simulation du Potentiel de Membrane (Modèle Hodgkin-Huxley)')
plt.xlabel('Temps (ms)')
plt.ylabel('Potentiel de Membrane (mV)')
plt.grid(True)
plt.show()
